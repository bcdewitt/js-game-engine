<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>tiledMap.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-AssetManager-AssetManager.html">AssetManager</a><ul class='methods'><li data-type='method'><a href="module-AssetManager-AssetManager.html#downloadAll">downloadAll</a></li><li data-type='method'><a href="module-AssetManager-AssetManager.html#getAsset">getAsset</a></li><li data-type='method'><a href="module-AssetManager-AssetManager.html#init">init</a></li><li data-type='method'><a href="module-AssetManager-AssetManager.html#isDone">isDone</a></li><li data-type='method'><a href="module-AssetManager-AssetManager.html#queueDownload">queueDownload</a></li><li data-type='method'><a href="module-AssetManager-AssetManager.html#queueDownloads">queueDownloads</a></li></ul></li><li><a href="module-Engine-GameEngine.html">GameEngine</a><ul class='methods'><li data-type='method'><a href="module-Engine-GameEngine.html#addEntity">addEntity</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#addEntitySubset">addEntitySubset</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#addSystem">addSystem</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#addSystems">addSystems</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#getAssetPaths">getAssetPaths</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#getEntities">getEntities</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#onAssetsLoaded">onAssetsLoaded</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#removeEntity">removeEntity</a></li><li data-type='method'><a href="module-Engine-GameEngine.html#run">run</a></li></ul></li><li><a href="module-EntityManager-EntityManager.html">EntityManager</a><ul class='methods'><li data-type='method'><a href="module-EntityManager-EntityManager.html#addEntity">addEntity</a></li><li data-type='method'><a href="module-EntityManager-EntityManager.html#addEntitySubset">addEntitySubset</a></li><li data-type='method'><a href="module-EntityManager-EntityManager.html#getEntities">getEntities</a></li><li data-type='method'><a href="module-EntityManager-EntityManager.html#removeEntity">removeEntity</a></li></ul></li><li><a href="module-Entity-Entity.html">Entity</a><ul class='methods'><li data-type='method'><a href="module-Entity-Entity.html#addComponent">addComponent</a></li><li data-type='method'><a href="module-Entity-Entity.html#getComponent">getComponent</a></li><li data-type='method'><a href="module-Entity-Entity.html#hasComponent">hasComponent</a></li><li data-type='method'><a href="module-Entity-Entity.html#removeComponent">removeComponent</a></li></ul></li><li><a href="module-ExampleEntityFactory-ExampleEntityFactory.html">ExampleEntityFactory</a><ul class='methods'><li data-type='method'><a href="module-ExampleEntityFactory-ExampleEntityFactory.html#create">create</a></li></ul></li><li><a href="module-ExampleSpawnerSystem-ExampleSpawnerSystem.html">ExampleSpawnerSystem</a><ul class='methods'><li data-type='method'><a href="module-ExampleSpawnerSystem-ExampleSpawnerSystem.html#getRequiredSubsets">getRequiredSubsets</a></li><li data-type='method'><a href="module-ExampleSpawnerSystem-ExampleSpawnerSystem.html#run">run</a></li></ul></li><li><a href="module-RenderSystem-ExampleRenderSystem.html">ExampleRenderSystem</a><ul class='methods'><li data-type='method'><a href="module-RenderSystem-ExampleRenderSystem.html#getAssetPaths">getAssetPaths</a></li><li data-type='method'><a href="module-RenderSystem-ExampleRenderSystem.html#getRequiredSubsets">getRequiredSubsets</a></li><li data-type='method'><a href="module-RenderSystem-ExampleRenderSystem.html#onAssetsLoaded">onAssetsLoaded</a></li><li data-type='method'><a href="module-RenderSystem-ExampleRenderSystem.html#run">run</a></li></ul></li><li><a href="module-TiledMap-TiledMap.html">TiledMap</a><ul class='methods'><li data-type='method'><a href="module-TiledMap-TiledMap.html#getAssetPaths">getAssetPaths</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#onAssetsLoaded">onAssetsLoaded</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#populateLayerCanvases">populateLayerCanvases</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#populateLayers">populateLayers</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#populateTiles">populateTiles</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#render">render</a></li><li data-type='method'><a href="module-TiledMap-TiledMap.html#renderAnimatedTiles">renderAnimatedTiles</a></li></ul></li><li><a href="module-utilities-Utilities.html">Utilities</a><ul class='methods'><li data-type='method'><a href="module-utilities-Utilities.html#createArray">createArray</a></li><li data-type='method'><a href="module-utilities-Utilities.html#createIterableObject">createIterableObject</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-AssetManager.html">AssetManager</a></li><li><a href="module-AssetUser.html">AssetUser</a></li><li><a href="module-Engine.html">Engine</a></li><li><a href="module-Entity.html">Entity</a></li><li><a href="module-EntityFactory.html">EntityFactory</a></li><li><a href="module-EntityManager.html">EntityManager</a></li><li><a href="module-ExampleEntityFactory.html">ExampleEntityFactory</a></li><li><a href="module-ExampleSpawnerSystem.html">ExampleSpawnerSystem</a></li><li><a href="module-RenderSystem.html">RenderSystem</a></li><li><a href="module-System.html">System</a></li><li><a href="module-TiledMap.html">TiledMap</a></li><li><a href="module-utilities.html">utilities</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-AssetUser-AssetUser.html">AssetUser</a><ul class='methods'><li data-type='method'><a href="module-AssetUser-AssetUser.html#getAssetPaths">getAssetPaths</a></li><li data-type='method'><a href="module-AssetUser-AssetUser.html#onAssetsLoaded">onAssetsLoaded</a></li></ul></li><li><a href="module-EntityFactory-EntityFactory.html">EntityFactory</a><ul class='methods'><li data-type='method'><a href="module-EntityFactory-EntityFactory.html#create">create</a></li></ul></li><li><a href="module-System-System.html">System</a><ul class='methods'><li data-type='method'><a href="module-System-System.html#addEntity">addEntity</a></li><li data-type='method'><a href="module-System-System.html#getEntities">getEntities</a></li><li data-type='method'><a href="module-System-System.html#getRequiredSubsets">getRequiredSubsets</a></li><li data-type='method'><a href="module-System-System.html#removeEntity">removeEntity</a></li><li data-type='method'><a href="module-System-System.html#run">run</a></li><li data-type='method'><a href="module-System-System.html#setEntityManager">setEntityManager</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">tiledMap.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * TiledMap module.
 * @module TiledMap
 */
define('TiledMap', function(module) {
	'use strict';

	const AssetUser = require('AssetUser');
	const utilities = require('utilities');

	/** Class representing a Map built from Tiled data. */
	class TiledMap extends AssetUser {
		constructor(data) {
			super();
			this.data = data;
			this.assets = {};

			this.tileWidth = data.tilewidth || 0;
			this.tileHeight = data.tileheight || 0;
			this.tiles = [];
			this.layers = {};
			this.objects = [];
			this.layerCanvases = {};
		}

		/**
		 * @returns {array}  Array of path strings or plain objects with a "path" and "reviver" function (for JSON)
		 */
		getAssetPaths() {
			let paths = [];

			paths.push(this.data.properties.bgm);

			this.data.tilesets.forEach(function(tileset) {
				paths.push(tileset.image);
			});

			return paths;
		}

		/**
		 * Event handler function - Store downloaded assets
		 * @param {Object} assets - Plain object that works as an associative array. Each item key is a path from "getAssetPaths()"
		 */
		onAssetsLoaded(assets) {
			this.assets = assets;

			this.bgm = this.data.properties &amp;&amp; assets[this.data.properties.bgm];

			// Populate this.tiles array
			this.populateTiles(this.data.tilesets);

			// Split up each layer's data into x and y coordinate multidimensional array
			this.populateLayers(this.data.layers);

			// Draw the non-animated parts of each map layer on stored canvases (speeds up rendering at runtime)
			this.populateLayerCanvases();

			super.onAssetsLoaded();
		}

		getObjects() {
			return this.objects;
		}

		/**
		 * Creates in-memory representations of tiles using given tilesets.
		 * @param  {Object[]} tilesets - Array of plain objects representing tileset data.
		 */
		populateTiles(tilesets) {
			for(let tileset of tilesets) {
				let img = this.assets[tileset.image];

				let yInc = tileset.tileheight + tileset.spacing;
				for(let y = tileset.margin; this.tiles.length &lt; tileset.tilecount; y += yInc) {

					let xInc = tileset.tilewidth + tileset.spacing;
					for(let x = tileset.margin, l = (tileset.columns * tileset.tilewidth); x &lt; l; x += xInc) {
						let obj = {
							img: img,
							x: x,
							y: y,
							width: tileset.tilewidth,
							height: tileset.tileheight
						};
						let extraData = tileset.tiles &amp;&amp; tileset.tiles[this.tiles.length];

						if(extraData &amp;&amp; extraData.animation) {
							let rangeStart = 0;
							let rangeEnd = 0;
							obj.animation = [];

							for(let step of extraData.animation) {
								rangeStart = rangeEnd;
								rangeEnd = rangeStart + step.duration;
								obj.animation.push({
									rangeStart: rangeStart,
									rangeEnd: rangeEnd,
									tileid: step.tileid
								});
							}
						}

						this.tiles.push(obj);
					}
				}
			}
		}

		/**
		 * Creates in-memory representations of layers and objects using given layers data.
		 * @param  {Object[]} layers - Array of plain objects representing layer data.
		 */
		populateLayers(layers) {
			for(let layer of layers) {
				if(layer.data &amp;&amp; layer.type === 'tilelayer') {
					let layerData = utilities.createArray(layer.width, layer.height);
					let idx = 0;

					for(let y = 0, l = layer.height; y &lt; l; y++) {
						for(let x = 0, l2 = layer.width; x &lt; l2; x++) {
							layerData[x][y] = layer.data[idx++];
						}
					}

					this.layers[layer.name] = {
						width: layer.width,
						height: layer.height,
						data: layerData
					};
				} else if (layer.type === 'objectgroup') {
					let objects = layer.objects;
					for(let object of objects) {
						let obj = {
							width: object.width,
							height: object.height,
							x: object.x,
							y: object.y,
							type: object.type,
							name: object.name
						};

						for(let key in object.properties) {
							obj[key] = object.properties[key];
						}

						this.objects.push(obj);
					}
				}
			}
		}

		/**
		 * Creates and draws canvases for each layer in this.layers. Only non-animated tiles are drawn.
		 */
		populateLayerCanvases() {

			for (let layerName in this.layers) {
				let layer = this.layers[layerName];
				let canvas = document.createElement('canvas');
				canvas.width = layer.width * this.tileWidth;
				canvas.height = layer.height * this.tileHeight;
				let context = canvas.getContext('2d');

				if(layer &amp;&amp; layer.data) {
					for(let y = 0, l = layer.height; y &lt; l; y++) {
						for(let x = 0, l2 = layer.width; x &lt; l2; x++) {
							let tile = this.tiles[layer.data[x][y] - 1];
							let posX = x * this.tileWidth;
							let posY = y * this.tileHeight;

							if(tile &amp;&amp; tile.animation === undefined) {
								context.drawImage(
									tile.img,
									tile.x,
									tile.y,
									tile.width,
									tile.height,
									posX,
									posY,
									this.tileWidth,
									this.tileHeight
								);
							}

						}
					}
				}

				this.layerCanvases[layerName] = canvas;
			}

		}

		/**
		 * Render animated tiles within the given area of a layer (tile frame depends on given time).
		 * @param  {CanvasRenderingContext2D} context - Provides API to draw on a canvas.
		 * @param  {string} layerName                 - Key referencing layer in this.layers.
		 * @param  {DOMHighResTimeStamp} time         - Time in milliseconds since first render.
		 * @param  {number} tileX1                    - x-coordinate at top left in number of tiles from left.
		 * @param  {number} tileY1                    - y-coordinate at top left in number of tiles from left.
		 * @param  {number} tileX2                    - x-coordinate at bottom right in number of tiles from left.
		 * @param  {number} tileY2                    - y-coordinate at bottom right in number of tiles from left.
		 * @param  {number} dX                        - x-coordinate at top left of destination in pixels from left.
		 * @param  {number} dY                        - y-coordinate at top left of destination in pixels from left.
		 * @param  {number} scaleW                    - scaling for width.
		 * @param  {number} scaleH                    - scaling for height.
		 */
		renderAnimatedTiles(context, layerName, time, tileX1, tileY1, tileX2, tileY2, dX, dY, scaleW, scaleH) {
			let layer = this.layers[layerName];

			if(layer &amp;&amp; layer.data) {
				for(let y = tileY1, l = Math.min(layer.height, tileY2); y &lt; l; y++) {
					for(let x = tileX1, l2 = Math.min(layer.width, tileX2); x &lt; l2; x++) {
						let tile = this.tiles[layer.data[x][y] - 1];
						let posX = (x * this.tileWidth) + dX;
						let posY = (y * this.tileHeight) + dY;

						if(tile &amp;&amp; tile.animation) {
							let wrappedTime = time % tile.animation[tile.animation.length - 1].rangeEnd;
							for(let step of tile.animation) {
								if(wrappedTime > step.rangeStart &amp;&amp; wrappedTime &lt; step.rangeEnd) {
									tile = this.tiles[step.tileid];
								}
							}

							context.drawImage(
								tile.img,
								tile.x,
								tile.y,
								tile.width,
								tile.height,
								posX,
								posY,
								this.tileWidth * scaleW,
								this.tileHeight * scaleH
							);

						}
					}
				}
			}

		}

		/**
		 * Render given area of a layer.
		 * @param  {CanvasRenderingContext2D} context - Provides API to draw on a canvas.
		 * @param  {string} layerName                 - Key referencing layer in this.layers.
		 * @param  {DOMHighResTimeStamp} timestamp    - Current time in milliseconds.
		 * @param  {number} sX                        - x-coordinate at top left of source in pixels from left.
		 * @param  {number} sY                        - y-coordinate at top left of source in pixels from left.
		 * @param  {number} sW                        - width of source in pixels.
		 * @param  {number} sH                        - height of source in pixels.
		 * @param  {number} dX                        - x-coordinate at top left of destination in pixels from left.
		 * @param  {number} dY                        - y-coordinate at top left of destination in pixels from left.
		 * @param  {number} dW                        - width of destination in pixels.
		 * @param  {number} dH                        - height of destination in pixels.
		 */
		render(context, layerName, timestamp, sX, sY, sW, sH, dX, dY, dW, dH) {
			// Note: May need to use context.getImageData() and .putImageData() for transparency support instead of .drawImage()
			// ...I tried these but they created memory leaks when debugging with Chrome

			this.startTime = this.startTime || timestamp;

			let canvas = this.layerCanvases[layerName];

			if(canvas) {

				// Draw static parts of layer
				context.drawImage(canvas, sX, sY, sW, sH, dX, dY, dW, dH);

				// Draw animated parts of layer
				this.renderAnimatedTiles(
					context,
					layerName,
					(timestamp - this.startTime),         // get time since first render (for animation)
					parseInt(sX / this.tileWidth),        // calc x1 in tile units
					parseInt(sY / this.tileHeight),       // calc y1 in tile units
					parseInt(sX + sW) / this.tileWidth,   // calc x2 in tile units
					parseInt(sY + sH) / this.tileHeight,  // calc y2 in tile units
					dX, dY, dW / sW, dH / sH              // destination x, y, scaling-x, scaling-y
				);

			}

		}
	}

	module.exports = TiledMap;

});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Tue Nov 08 2016 18:39:47 GMT-0500 (Eastern Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
